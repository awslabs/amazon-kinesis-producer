// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace aws {
namespace kinesis {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2eproto();
void protobuf_AssignDesc_config_2eproto();
void protobuf_ShutdownFile_config_2eproto();

class AdditionalDimension;
class Configuration;

enum Configuration_ThreadConfig {
  Configuration_ThreadConfig_PER_REQUEST = 0,
  Configuration_ThreadConfig_POOLED = 1
};
bool Configuration_ThreadConfig_IsValid(int value);
const Configuration_ThreadConfig Configuration_ThreadConfig_ThreadConfig_MIN = Configuration_ThreadConfig_PER_REQUEST;
const Configuration_ThreadConfig Configuration_ThreadConfig_ThreadConfig_MAX = Configuration_ThreadConfig_POOLED;
const int Configuration_ThreadConfig_ThreadConfig_ARRAYSIZE = Configuration_ThreadConfig_ThreadConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* Configuration_ThreadConfig_descriptor();
inline const ::std::string& Configuration_ThreadConfig_Name(Configuration_ThreadConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    Configuration_ThreadConfig_descriptor(), value);
}
inline bool Configuration_ThreadConfig_Parse(
    const ::std::string& name, Configuration_ThreadConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_ThreadConfig>(
    Configuration_ThreadConfig_descriptor(), name, value);
}
// ===================================================================

class AdditionalDimension : public ::google::protobuf::Message {
 public:
  AdditionalDimension();
  virtual ~AdditionalDimension();

  AdditionalDimension(const AdditionalDimension& from);

  inline AdditionalDimension& operator=(const AdditionalDimension& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdditionalDimension& default_instance();

  void Swap(AdditionalDimension* other);

  // implements Message ----------------------------------------------

  AdditionalDimension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdditionalDimension& from);
  void MergeFrom(const AdditionalDimension& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required string granularity = 3;
  inline bool has_granularity() const;
  inline void clear_granularity();
  static const int kGranularityFieldNumber = 3;
  inline const ::std::string& granularity() const;
  inline void set_granularity(const ::std::string& value);
  inline void set_granularity(const char* value);
  inline void set_granularity(const char* value, size_t size);
  inline ::std::string* mutable_granularity();
  inline ::std::string* release_granularity();
  inline void set_allocated_granularity(::std::string* granularity);

  // @@protoc_insertion_point(class_scope:aws.kinesis.protobuf.AdditionalDimension)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_granularity();
  inline void clear_has_granularity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  ::std::string* granularity_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static AdditionalDimension* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Configuration_ThreadConfig ThreadConfig;
  static const ThreadConfig PER_REQUEST = Configuration_ThreadConfig_PER_REQUEST;
  static const ThreadConfig POOLED = Configuration_ThreadConfig_POOLED;
  static inline bool ThreadConfig_IsValid(int value) {
    return Configuration_ThreadConfig_IsValid(value);
  }
  static const ThreadConfig ThreadConfig_MIN =
    Configuration_ThreadConfig_ThreadConfig_MIN;
  static const ThreadConfig ThreadConfig_MAX =
    Configuration_ThreadConfig_ThreadConfig_MAX;
  static const int ThreadConfig_ARRAYSIZE =
    Configuration_ThreadConfig_ThreadConfig_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ThreadConfig_descriptor() {
    return Configuration_ThreadConfig_descriptor();
  }
  static inline const ::std::string& ThreadConfig_Name(ThreadConfig value) {
    return Configuration_ThreadConfig_Name(value);
  }
  static inline bool ThreadConfig_Parse(const ::std::string& name,
      ThreadConfig* value) {
    return Configuration_ThreadConfig_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .aws.kinesis.protobuf.AdditionalDimension additional_metric_dims = 128;
  inline int additional_metric_dims_size() const;
  inline void clear_additional_metric_dims();
  static const int kAdditionalMetricDimsFieldNumber = 128;
  inline const ::aws::kinesis::protobuf::AdditionalDimension& additional_metric_dims(int index) const;
  inline ::aws::kinesis::protobuf::AdditionalDimension* mutable_additional_metric_dims(int index);
  inline ::aws::kinesis::protobuf::AdditionalDimension* add_additional_metric_dims();
  inline const ::google::protobuf::RepeatedPtrField< ::aws::kinesis::protobuf::AdditionalDimension >&
      additional_metric_dims() const;
  inline ::google::protobuf::RepeatedPtrField< ::aws::kinesis::protobuf::AdditionalDimension >*
      mutable_additional_metric_dims();

  // optional bool aggregation_enabled = 1 [default = true];
  inline bool has_aggregation_enabled() const;
  inline void clear_aggregation_enabled();
  static const int kAggregationEnabledFieldNumber = 1;
  inline bool aggregation_enabled() const;
  inline void set_aggregation_enabled(bool value);

  // optional uint64 aggregation_max_count = 2 [default = 4294967295];
  inline bool has_aggregation_max_count() const;
  inline void clear_aggregation_max_count();
  static const int kAggregationMaxCountFieldNumber = 2;
  inline ::google::protobuf::uint64 aggregation_max_count() const;
  inline void set_aggregation_max_count(::google::protobuf::uint64 value);

  // optional uint64 aggregation_max_size = 3 [default = 51200];
  inline bool has_aggregation_max_size() const;
  inline void clear_aggregation_max_size();
  static const int kAggregationMaxSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 aggregation_max_size() const;
  inline void set_aggregation_max_size(::google::protobuf::uint64 value);

  // optional string cloudwatch_endpoint = 4 [default = ""];
  inline bool has_cloudwatch_endpoint() const;
  inline void clear_cloudwatch_endpoint();
  static const int kCloudwatchEndpointFieldNumber = 4;
  inline const ::std::string& cloudwatch_endpoint() const;
  inline void set_cloudwatch_endpoint(const ::std::string& value);
  inline void set_cloudwatch_endpoint(const char* value);
  inline void set_cloudwatch_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_cloudwatch_endpoint();
  inline ::std::string* release_cloudwatch_endpoint();
  inline void set_allocated_cloudwatch_endpoint(::std::string* cloudwatch_endpoint);

  // optional uint64 cloudwatch_port = 5 [default = 443];
  inline bool has_cloudwatch_port() const;
  inline void clear_cloudwatch_port();
  static const int kCloudwatchPortFieldNumber = 5;
  inline ::google::protobuf::uint64 cloudwatch_port() const;
  inline void set_cloudwatch_port(::google::protobuf::uint64 value);

  // optional uint64 collection_max_count = 6 [default = 500];
  inline bool has_collection_max_count() const;
  inline void clear_collection_max_count();
  static const int kCollectionMaxCountFieldNumber = 6;
  inline ::google::protobuf::uint64 collection_max_count() const;
  inline void set_collection_max_count(::google::protobuf::uint64 value);

  // optional uint64 collection_max_size = 7 [default = 5242880];
  inline bool has_collection_max_size() const;
  inline void clear_collection_max_size();
  static const int kCollectionMaxSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 collection_max_size() const;
  inline void set_collection_max_size(::google::protobuf::uint64 value);

  // optional uint64 connect_timeout = 8 [default = 6000];
  inline bool has_connect_timeout() const;
  inline void clear_connect_timeout();
  static const int kConnectTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint64 connect_timeout() const;
  inline void set_connect_timeout(::google::protobuf::uint64 value);

  // optional bool enable_core_dumps = 9 [default = false];
  inline bool has_enable_core_dumps() const;
  inline void clear_enable_core_dumps();
  static const int kEnableCoreDumpsFieldNumber = 9;
  inline bool enable_core_dumps() const;
  inline void set_enable_core_dumps(bool value);

  // optional bool fail_if_throttled = 10 [default = false];
  inline bool has_fail_if_throttled() const;
  inline void clear_fail_if_throttled();
  static const int kFailIfThrottledFieldNumber = 10;
  inline bool fail_if_throttled() const;
  inline void set_fail_if_throttled(bool value);

  // optional string kinesis_endpoint = 11 [default = ""];
  inline bool has_kinesis_endpoint() const;
  inline void clear_kinesis_endpoint();
  static const int kKinesisEndpointFieldNumber = 11;
  inline const ::std::string& kinesis_endpoint() const;
  inline void set_kinesis_endpoint(const ::std::string& value);
  inline void set_kinesis_endpoint(const char* value);
  inline void set_kinesis_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_kinesis_endpoint();
  inline ::std::string* release_kinesis_endpoint();
  inline void set_allocated_kinesis_endpoint(::std::string* kinesis_endpoint);

  // optional uint64 kinesis_port = 12 [default = 443];
  inline bool has_kinesis_port() const;
  inline void clear_kinesis_port();
  static const int kKinesisPortFieldNumber = 12;
  inline ::google::protobuf::uint64 kinesis_port() const;
  inline void set_kinesis_port(::google::protobuf::uint64 value);

  // optional string log_level = 13 [default = "info"];
  inline bool has_log_level() const;
  inline void clear_log_level();
  static const int kLogLevelFieldNumber = 13;
  inline const ::std::string& log_level() const;
  inline void set_log_level(const ::std::string& value);
  inline void set_log_level(const char* value);
  inline void set_log_level(const char* value, size_t size);
  inline ::std::string* mutable_log_level();
  inline ::std::string* release_log_level();
  inline void set_allocated_log_level(::std::string* log_level);

  // optional uint64 max_connections = 14 [default = 24];
  inline bool has_max_connections() const;
  inline void clear_max_connections();
  static const int kMaxConnectionsFieldNumber = 14;
  inline ::google::protobuf::uint64 max_connections() const;
  inline void set_max_connections(::google::protobuf::uint64 value);

  // optional string metrics_granularity = 15 [default = "shard"];
  inline bool has_metrics_granularity() const;
  inline void clear_metrics_granularity();
  static const int kMetricsGranularityFieldNumber = 15;
  inline const ::std::string& metrics_granularity() const;
  inline void set_metrics_granularity(const ::std::string& value);
  inline void set_metrics_granularity(const char* value);
  inline void set_metrics_granularity(const char* value, size_t size);
  inline ::std::string* mutable_metrics_granularity();
  inline ::std::string* release_metrics_granularity();
  inline void set_allocated_metrics_granularity(::std::string* metrics_granularity);

  // optional string metrics_level = 16 [default = "detailed"];
  inline bool has_metrics_level() const;
  inline void clear_metrics_level();
  static const int kMetricsLevelFieldNumber = 16;
  inline const ::std::string& metrics_level() const;
  inline void set_metrics_level(const ::std::string& value);
  inline void set_metrics_level(const char* value);
  inline void set_metrics_level(const char* value, size_t size);
  inline ::std::string* mutable_metrics_level();
  inline ::std::string* release_metrics_level();
  inline void set_allocated_metrics_level(::std::string* metrics_level);

  // optional string metrics_namespace = 17 [default = "KinesisProducerLibrary"];
  inline bool has_metrics_namespace() const;
  inline void clear_metrics_namespace();
  static const int kMetricsNamespaceFieldNumber = 17;
  inline const ::std::string& metrics_namespace() const;
  inline void set_metrics_namespace(const ::std::string& value);
  inline void set_metrics_namespace(const char* value);
  inline void set_metrics_namespace(const char* value, size_t size);
  inline ::std::string* mutable_metrics_namespace();
  inline ::std::string* release_metrics_namespace();
  inline void set_allocated_metrics_namespace(::std::string* metrics_namespace);

  // optional uint64 metrics_upload_delay = 18 [default = 60000];
  inline bool has_metrics_upload_delay() const;
  inline void clear_metrics_upload_delay();
  static const int kMetricsUploadDelayFieldNumber = 18;
  inline ::google::protobuf::uint64 metrics_upload_delay() const;
  inline void set_metrics_upload_delay(::google::protobuf::uint64 value);

  // optional uint64 min_connections = 19 [default = 1];
  inline bool has_min_connections() const;
  inline void clear_min_connections();
  static const int kMinConnectionsFieldNumber = 19;
  inline ::google::protobuf::uint64 min_connections() const;
  inline void set_min_connections(::google::protobuf::uint64 value);

  // optional uint64 rate_limit = 20 [default = 150];
  inline bool has_rate_limit() const;
  inline void clear_rate_limit();
  static const int kRateLimitFieldNumber = 20;
  inline ::google::protobuf::uint64 rate_limit() const;
  inline void set_rate_limit(::google::protobuf::uint64 value);

  // optional uint64 record_max_buffered_time = 21 [default = 100];
  inline bool has_record_max_buffered_time() const;
  inline void clear_record_max_buffered_time();
  static const int kRecordMaxBufferedTimeFieldNumber = 21;
  inline ::google::protobuf::uint64 record_max_buffered_time() const;
  inline void set_record_max_buffered_time(::google::protobuf::uint64 value);

  // optional uint64 record_ttl = 22 [default = 30000];
  inline bool has_record_ttl() const;
  inline void clear_record_ttl();
  static const int kRecordTtlFieldNumber = 22;
  inline ::google::protobuf::uint64 record_ttl() const;
  inline void set_record_ttl(::google::protobuf::uint64 value);

  // optional string region = 23 [default = ""];
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 23;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  inline void set_allocated_region(::std::string* region);

  // optional uint64 request_timeout = 24 [default = 6000];
  inline bool has_request_timeout() const;
  inline void clear_request_timeout();
  static const int kRequestTimeoutFieldNumber = 24;
  inline ::google::protobuf::uint64 request_timeout() const;
  inline void set_request_timeout(::google::protobuf::uint64 value);

  // optional bool verify_certificate = 25 [default = true];
  inline bool has_verify_certificate() const;
  inline void clear_verify_certificate();
  static const int kVerifyCertificateFieldNumber = 25;
  inline bool verify_certificate() const;
  inline void set_verify_certificate(bool value);

  // optional .aws.kinesis.protobuf.Configuration.ThreadConfig thread_config = 26 [default = PER_REQUEST];
  inline bool has_thread_config() const;
  inline void clear_thread_config();
  static const int kThreadConfigFieldNumber = 26;
  inline ::aws::kinesis::protobuf::Configuration_ThreadConfig thread_config() const;
  inline void set_thread_config(::aws::kinesis::protobuf::Configuration_ThreadConfig value);

  // optional uint32 thread_pool_size = 27 [default = 64];
  inline bool has_thread_pool_size() const;
  inline void clear_thread_pool_size();
  static const int kThreadPoolSizeFieldNumber = 27;
  inline ::google::protobuf::uint32 thread_pool_size() const;
  inline void set_thread_pool_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aws.kinesis.protobuf.Configuration)
 private:
  inline void set_has_aggregation_enabled();
  inline void clear_has_aggregation_enabled();
  inline void set_has_aggregation_max_count();
  inline void clear_has_aggregation_max_count();
  inline void set_has_aggregation_max_size();
  inline void clear_has_aggregation_max_size();
  inline void set_has_cloudwatch_endpoint();
  inline void clear_has_cloudwatch_endpoint();
  inline void set_has_cloudwatch_port();
  inline void clear_has_cloudwatch_port();
  inline void set_has_collection_max_count();
  inline void clear_has_collection_max_count();
  inline void set_has_collection_max_size();
  inline void clear_has_collection_max_size();
  inline void set_has_connect_timeout();
  inline void clear_has_connect_timeout();
  inline void set_has_enable_core_dumps();
  inline void clear_has_enable_core_dumps();
  inline void set_has_fail_if_throttled();
  inline void clear_has_fail_if_throttled();
  inline void set_has_kinesis_endpoint();
  inline void clear_has_kinesis_endpoint();
  inline void set_has_kinesis_port();
  inline void clear_has_kinesis_port();
  inline void set_has_log_level();
  inline void clear_has_log_level();
  inline void set_has_max_connections();
  inline void clear_has_max_connections();
  inline void set_has_metrics_granularity();
  inline void clear_has_metrics_granularity();
  inline void set_has_metrics_level();
  inline void clear_has_metrics_level();
  inline void set_has_metrics_namespace();
  inline void clear_has_metrics_namespace();
  inline void set_has_metrics_upload_delay();
  inline void clear_has_metrics_upload_delay();
  inline void set_has_min_connections();
  inline void clear_has_min_connections();
  inline void set_has_rate_limit();
  inline void clear_has_rate_limit();
  inline void set_has_record_max_buffered_time();
  inline void clear_has_record_max_buffered_time();
  inline void set_has_record_ttl();
  inline void clear_has_record_ttl();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_request_timeout();
  inline void clear_has_request_timeout();
  inline void set_has_verify_certificate();
  inline void clear_has_verify_certificate();
  inline void set_has_thread_config();
  inline void clear_has_thread_config();
  inline void set_has_thread_pool_size();
  inline void clear_has_thread_pool_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aws::kinesis::protobuf::AdditionalDimension > additional_metric_dims_;
  ::google::protobuf::uint64 aggregation_max_count_;
  ::google::protobuf::uint64 aggregation_max_size_;
  ::std::string* cloudwatch_endpoint_;
  ::google::protobuf::uint64 cloudwatch_port_;
  ::google::protobuf::uint64 collection_max_count_;
  ::google::protobuf::uint64 collection_max_size_;
  ::google::protobuf::uint64 connect_timeout_;
  ::std::string* kinesis_endpoint_;
  ::google::protobuf::uint64 kinesis_port_;
  static ::std::string* _default_log_level_;
  ::std::string* log_level_;
  ::google::protobuf::uint64 max_connections_;
  bool aggregation_enabled_;
  bool enable_core_dumps_;
  bool fail_if_throttled_;
  bool verify_certificate_;
  int thread_config_;
  static ::std::string* _default_metrics_granularity_;
  ::std::string* metrics_granularity_;
  static ::std::string* _default_metrics_level_;
  ::std::string* metrics_level_;
  static ::std::string* _default_metrics_namespace_;
  ::std::string* metrics_namespace_;
  ::google::protobuf::uint64 metrics_upload_delay_;
  ::google::protobuf::uint64 min_connections_;
  ::google::protobuf::uint64 rate_limit_;
  ::google::protobuf::uint64 record_max_buffered_time_;
  ::google::protobuf::uint64 record_ttl_;
  ::std::string* region_;
  ::google::protobuf::uint64 request_timeout_;
  ::google::protobuf::uint32 thread_pool_size_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// ===================================================================


// ===================================================================

// AdditionalDimension

// required string key = 1;
inline bool AdditionalDimension::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdditionalDimension::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdditionalDimension::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdditionalDimension::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AdditionalDimension::key() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.AdditionalDimension.key)
  return *key_;
}
inline void AdditionalDimension::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.AdditionalDimension.key)
}
inline void AdditionalDimension::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.AdditionalDimension.key)
}
inline void AdditionalDimension::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.AdditionalDimension.key)
}
inline ::std::string* AdditionalDimension::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.AdditionalDimension.key)
  return key_;
}
inline ::std::string* AdditionalDimension::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalDimension::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.AdditionalDimension.key)
}

// required string value = 2;
inline bool AdditionalDimension::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdditionalDimension::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdditionalDimension::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdditionalDimension::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AdditionalDimension::value() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.AdditionalDimension.value)
  return *value_;
}
inline void AdditionalDimension::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.AdditionalDimension.value)
}
inline void AdditionalDimension::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.AdditionalDimension.value)
}
inline void AdditionalDimension::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.AdditionalDimension.value)
}
inline ::std::string* AdditionalDimension::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.AdditionalDimension.value)
  return value_;
}
inline ::std::string* AdditionalDimension::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalDimension::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.AdditionalDimension.value)
}

// required string granularity = 3;
inline bool AdditionalDimension::has_granularity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdditionalDimension::set_has_granularity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdditionalDimension::clear_has_granularity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdditionalDimension::clear_granularity() {
  if (granularity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    granularity_->clear();
  }
  clear_has_granularity();
}
inline const ::std::string& AdditionalDimension::granularity() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.AdditionalDimension.granularity)
  return *granularity_;
}
inline void AdditionalDimension::set_granularity(const ::std::string& value) {
  set_has_granularity();
  if (granularity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    granularity_ = new ::std::string;
  }
  granularity_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.AdditionalDimension.granularity)
}
inline void AdditionalDimension::set_granularity(const char* value) {
  set_has_granularity();
  if (granularity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    granularity_ = new ::std::string;
  }
  granularity_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.AdditionalDimension.granularity)
}
inline void AdditionalDimension::set_granularity(const char* value, size_t size) {
  set_has_granularity();
  if (granularity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    granularity_ = new ::std::string;
  }
  granularity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.AdditionalDimension.granularity)
}
inline ::std::string* AdditionalDimension::mutable_granularity() {
  set_has_granularity();
  if (granularity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    granularity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.AdditionalDimension.granularity)
  return granularity_;
}
inline ::std::string* AdditionalDimension::release_granularity() {
  clear_has_granularity();
  if (granularity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = granularity_;
    granularity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalDimension::set_allocated_granularity(::std::string* granularity) {
  if (granularity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete granularity_;
  }
  if (granularity) {
    set_has_granularity();
    granularity_ = granularity;
  } else {
    clear_has_granularity();
    granularity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.AdditionalDimension.granularity)
}

// -------------------------------------------------------------------

// Configuration

// repeated .aws.kinesis.protobuf.AdditionalDimension additional_metric_dims = 128;
inline int Configuration::additional_metric_dims_size() const {
  return additional_metric_dims_.size();
}
inline void Configuration::clear_additional_metric_dims() {
  additional_metric_dims_.Clear();
}
inline const ::aws::kinesis::protobuf::AdditionalDimension& Configuration::additional_metric_dims(int index) const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.additional_metric_dims)
  return additional_metric_dims_.Get(index);
}
inline ::aws::kinesis::protobuf::AdditionalDimension* Configuration::mutable_additional_metric_dims(int index) {
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.additional_metric_dims)
  return additional_metric_dims_.Mutable(index);
}
inline ::aws::kinesis::protobuf::AdditionalDimension* Configuration::add_additional_metric_dims() {
  // @@protoc_insertion_point(field_add:aws.kinesis.protobuf.Configuration.additional_metric_dims)
  return additional_metric_dims_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aws::kinesis::protobuf::AdditionalDimension >&
Configuration::additional_metric_dims() const {
  // @@protoc_insertion_point(field_list:aws.kinesis.protobuf.Configuration.additional_metric_dims)
  return additional_metric_dims_;
}
inline ::google::protobuf::RepeatedPtrField< ::aws::kinesis::protobuf::AdditionalDimension >*
Configuration::mutable_additional_metric_dims() {
  // @@protoc_insertion_point(field_mutable_list:aws.kinesis.protobuf.Configuration.additional_metric_dims)
  return &additional_metric_dims_;
}

// optional bool aggregation_enabled = 1 [default = true];
inline bool Configuration::has_aggregation_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_aggregation_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_aggregation_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_aggregation_enabled() {
  aggregation_enabled_ = true;
  clear_has_aggregation_enabled();
}
inline bool Configuration::aggregation_enabled() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.aggregation_enabled)
  return aggregation_enabled_;
}
inline void Configuration::set_aggregation_enabled(bool value) {
  set_has_aggregation_enabled();
  aggregation_enabled_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.aggregation_enabled)
}

// optional uint64 aggregation_max_count = 2 [default = 4294967295];
inline bool Configuration::has_aggregation_max_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_aggregation_max_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_aggregation_max_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_aggregation_max_count() {
  aggregation_max_count_ = GOOGLE_ULONGLONG(4294967295);
  clear_has_aggregation_max_count();
}
inline ::google::protobuf::uint64 Configuration::aggregation_max_count() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.aggregation_max_count)
  return aggregation_max_count_;
}
inline void Configuration::set_aggregation_max_count(::google::protobuf::uint64 value) {
  set_has_aggregation_max_count();
  aggregation_max_count_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.aggregation_max_count)
}

// optional uint64 aggregation_max_size = 3 [default = 51200];
inline bool Configuration::has_aggregation_max_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_aggregation_max_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_aggregation_max_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_aggregation_max_size() {
  aggregation_max_size_ = GOOGLE_ULONGLONG(51200);
  clear_has_aggregation_max_size();
}
inline ::google::protobuf::uint64 Configuration::aggregation_max_size() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.aggregation_max_size)
  return aggregation_max_size_;
}
inline void Configuration::set_aggregation_max_size(::google::protobuf::uint64 value) {
  set_has_aggregation_max_size();
  aggregation_max_size_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.aggregation_max_size)
}

// optional string cloudwatch_endpoint = 4 [default = ""];
inline bool Configuration::has_cloudwatch_endpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_cloudwatch_endpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_cloudwatch_endpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_cloudwatch_endpoint() {
  if (cloudwatch_endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cloudwatch_endpoint_->clear();
  }
  clear_has_cloudwatch_endpoint();
}
inline const ::std::string& Configuration::cloudwatch_endpoint() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
  return *cloudwatch_endpoint_;
}
inline void Configuration::set_cloudwatch_endpoint(const ::std::string& value) {
  set_has_cloudwatch_endpoint();
  if (cloudwatch_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cloudwatch_endpoint_ = new ::std::string;
  }
  cloudwatch_endpoint_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
}
inline void Configuration::set_cloudwatch_endpoint(const char* value) {
  set_has_cloudwatch_endpoint();
  if (cloudwatch_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cloudwatch_endpoint_ = new ::std::string;
  }
  cloudwatch_endpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
}
inline void Configuration::set_cloudwatch_endpoint(const char* value, size_t size) {
  set_has_cloudwatch_endpoint();
  if (cloudwatch_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cloudwatch_endpoint_ = new ::std::string;
  }
  cloudwatch_endpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
}
inline ::std::string* Configuration::mutable_cloudwatch_endpoint() {
  set_has_cloudwatch_endpoint();
  if (cloudwatch_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cloudwatch_endpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
  return cloudwatch_endpoint_;
}
inline ::std::string* Configuration::release_cloudwatch_endpoint() {
  clear_has_cloudwatch_endpoint();
  if (cloudwatch_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cloudwatch_endpoint_;
    cloudwatch_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Configuration::set_allocated_cloudwatch_endpoint(::std::string* cloudwatch_endpoint) {
  if (cloudwatch_endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cloudwatch_endpoint_;
  }
  if (cloudwatch_endpoint) {
    set_has_cloudwatch_endpoint();
    cloudwatch_endpoint_ = cloudwatch_endpoint;
  } else {
    clear_has_cloudwatch_endpoint();
    cloudwatch_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.cloudwatch_endpoint)
}

// optional uint64 cloudwatch_port = 5 [default = 443];
inline bool Configuration::has_cloudwatch_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Configuration::set_has_cloudwatch_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Configuration::clear_has_cloudwatch_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Configuration::clear_cloudwatch_port() {
  cloudwatch_port_ = GOOGLE_ULONGLONG(443);
  clear_has_cloudwatch_port();
}
inline ::google::protobuf::uint64 Configuration::cloudwatch_port() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.cloudwatch_port)
  return cloudwatch_port_;
}
inline void Configuration::set_cloudwatch_port(::google::protobuf::uint64 value) {
  set_has_cloudwatch_port();
  cloudwatch_port_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.cloudwatch_port)
}

// optional uint64 collection_max_count = 6 [default = 500];
inline bool Configuration::has_collection_max_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Configuration::set_has_collection_max_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Configuration::clear_has_collection_max_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Configuration::clear_collection_max_count() {
  collection_max_count_ = GOOGLE_ULONGLONG(500);
  clear_has_collection_max_count();
}
inline ::google::protobuf::uint64 Configuration::collection_max_count() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.collection_max_count)
  return collection_max_count_;
}
inline void Configuration::set_collection_max_count(::google::protobuf::uint64 value) {
  set_has_collection_max_count();
  collection_max_count_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.collection_max_count)
}

// optional uint64 collection_max_size = 7 [default = 5242880];
inline bool Configuration::has_collection_max_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Configuration::set_has_collection_max_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Configuration::clear_has_collection_max_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Configuration::clear_collection_max_size() {
  collection_max_size_ = GOOGLE_ULONGLONG(5242880);
  clear_has_collection_max_size();
}
inline ::google::protobuf::uint64 Configuration::collection_max_size() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.collection_max_size)
  return collection_max_size_;
}
inline void Configuration::set_collection_max_size(::google::protobuf::uint64 value) {
  set_has_collection_max_size();
  collection_max_size_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.collection_max_size)
}

// optional uint64 connect_timeout = 8 [default = 6000];
inline bool Configuration::has_connect_timeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Configuration::set_has_connect_timeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Configuration::clear_has_connect_timeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Configuration::clear_connect_timeout() {
  connect_timeout_ = GOOGLE_ULONGLONG(6000);
  clear_has_connect_timeout();
}
inline ::google::protobuf::uint64 Configuration::connect_timeout() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.connect_timeout)
  return connect_timeout_;
}
inline void Configuration::set_connect_timeout(::google::protobuf::uint64 value) {
  set_has_connect_timeout();
  connect_timeout_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.connect_timeout)
}

// optional bool enable_core_dumps = 9 [default = false];
inline bool Configuration::has_enable_core_dumps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Configuration::set_has_enable_core_dumps() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Configuration::clear_has_enable_core_dumps() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Configuration::clear_enable_core_dumps() {
  enable_core_dumps_ = false;
  clear_has_enable_core_dumps();
}
inline bool Configuration::enable_core_dumps() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.enable_core_dumps)
  return enable_core_dumps_;
}
inline void Configuration::set_enable_core_dumps(bool value) {
  set_has_enable_core_dumps();
  enable_core_dumps_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.enable_core_dumps)
}

// optional bool fail_if_throttled = 10 [default = false];
inline bool Configuration::has_fail_if_throttled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Configuration::set_has_fail_if_throttled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Configuration::clear_has_fail_if_throttled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Configuration::clear_fail_if_throttled() {
  fail_if_throttled_ = false;
  clear_has_fail_if_throttled();
}
inline bool Configuration::fail_if_throttled() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.fail_if_throttled)
  return fail_if_throttled_;
}
inline void Configuration::set_fail_if_throttled(bool value) {
  set_has_fail_if_throttled();
  fail_if_throttled_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.fail_if_throttled)
}

// optional string kinesis_endpoint = 11 [default = ""];
inline bool Configuration::has_kinesis_endpoint() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Configuration::set_has_kinesis_endpoint() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Configuration::clear_has_kinesis_endpoint() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Configuration::clear_kinesis_endpoint() {
  if (kinesis_endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kinesis_endpoint_->clear();
  }
  clear_has_kinesis_endpoint();
}
inline const ::std::string& Configuration::kinesis_endpoint() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
  return *kinesis_endpoint_;
}
inline void Configuration::set_kinesis_endpoint(const ::std::string& value) {
  set_has_kinesis_endpoint();
  if (kinesis_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kinesis_endpoint_ = new ::std::string;
  }
  kinesis_endpoint_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
}
inline void Configuration::set_kinesis_endpoint(const char* value) {
  set_has_kinesis_endpoint();
  if (kinesis_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kinesis_endpoint_ = new ::std::string;
  }
  kinesis_endpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
}
inline void Configuration::set_kinesis_endpoint(const char* value, size_t size) {
  set_has_kinesis_endpoint();
  if (kinesis_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kinesis_endpoint_ = new ::std::string;
  }
  kinesis_endpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
}
inline ::std::string* Configuration::mutable_kinesis_endpoint() {
  set_has_kinesis_endpoint();
  if (kinesis_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kinesis_endpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
  return kinesis_endpoint_;
}
inline ::std::string* Configuration::release_kinesis_endpoint() {
  clear_has_kinesis_endpoint();
  if (kinesis_endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = kinesis_endpoint_;
    kinesis_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Configuration::set_allocated_kinesis_endpoint(::std::string* kinesis_endpoint) {
  if (kinesis_endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete kinesis_endpoint_;
  }
  if (kinesis_endpoint) {
    set_has_kinesis_endpoint();
    kinesis_endpoint_ = kinesis_endpoint;
  } else {
    clear_has_kinesis_endpoint();
    kinesis_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.kinesis_endpoint)
}

// optional uint64 kinesis_port = 12 [default = 443];
inline bool Configuration::has_kinesis_port() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Configuration::set_has_kinesis_port() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Configuration::clear_has_kinesis_port() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Configuration::clear_kinesis_port() {
  kinesis_port_ = GOOGLE_ULONGLONG(443);
  clear_has_kinesis_port();
}
inline ::google::protobuf::uint64 Configuration::kinesis_port() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.kinesis_port)
  return kinesis_port_;
}
inline void Configuration::set_kinesis_port(::google::protobuf::uint64 value) {
  set_has_kinesis_port();
  kinesis_port_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.kinesis_port)
}

// optional string log_level = 13 [default = "info"];
inline bool Configuration::has_log_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Configuration::set_has_log_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Configuration::clear_has_log_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Configuration::clear_log_level() {
  if (log_level_ != _default_log_level_) {
    log_level_->assign(*_default_log_level_);
  }
  clear_has_log_level();
}
inline const ::std::string& Configuration::log_level() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.log_level)
  return *log_level_;
}
inline void Configuration::set_log_level(const ::std::string& value) {
  set_has_log_level();
  if (log_level_ == _default_log_level_) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.log_level)
}
inline void Configuration::set_log_level(const char* value) {
  set_has_log_level();
  if (log_level_ == _default_log_level_) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.log_level)
}
inline void Configuration::set_log_level(const char* value, size_t size) {
  set_has_log_level();
  if (log_level_ == _default_log_level_) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.log_level)
}
inline ::std::string* Configuration::mutable_log_level() {
  set_has_log_level();
  if (log_level_ == _default_log_level_) {
    log_level_ = new ::std::string(*_default_log_level_);
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.log_level)
  return log_level_;
}
inline ::std::string* Configuration::release_log_level() {
  clear_has_log_level();
  if (log_level_ == _default_log_level_) {
    return NULL;
  } else {
    ::std::string* temp = log_level_;
    log_level_ = const_cast< ::std::string*>(_default_log_level_);
    return temp;
  }
}
inline void Configuration::set_allocated_log_level(::std::string* log_level) {
  if (log_level_ != _default_log_level_) {
    delete log_level_;
  }
  if (log_level) {
    set_has_log_level();
    log_level_ = log_level;
  } else {
    clear_has_log_level();
    log_level_ = const_cast< ::std::string*>(_default_log_level_);
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.log_level)
}

// optional uint64 max_connections = 14 [default = 24];
inline bool Configuration::has_max_connections() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Configuration::set_has_max_connections() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Configuration::clear_has_max_connections() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Configuration::clear_max_connections() {
  max_connections_ = GOOGLE_ULONGLONG(24);
  clear_has_max_connections();
}
inline ::google::protobuf::uint64 Configuration::max_connections() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.max_connections)
  return max_connections_;
}
inline void Configuration::set_max_connections(::google::protobuf::uint64 value) {
  set_has_max_connections();
  max_connections_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.max_connections)
}

// optional string metrics_granularity = 15 [default = "shard"];
inline bool Configuration::has_metrics_granularity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Configuration::set_has_metrics_granularity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Configuration::clear_has_metrics_granularity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Configuration::clear_metrics_granularity() {
  if (metrics_granularity_ != _default_metrics_granularity_) {
    metrics_granularity_->assign(*_default_metrics_granularity_);
  }
  clear_has_metrics_granularity();
}
inline const ::std::string& Configuration::metrics_granularity() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.metrics_granularity)
  return *metrics_granularity_;
}
inline void Configuration::set_metrics_granularity(const ::std::string& value) {
  set_has_metrics_granularity();
  if (metrics_granularity_ == _default_metrics_granularity_) {
    metrics_granularity_ = new ::std::string;
  }
  metrics_granularity_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.metrics_granularity)
}
inline void Configuration::set_metrics_granularity(const char* value) {
  set_has_metrics_granularity();
  if (metrics_granularity_ == _default_metrics_granularity_) {
    metrics_granularity_ = new ::std::string;
  }
  metrics_granularity_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.metrics_granularity)
}
inline void Configuration::set_metrics_granularity(const char* value, size_t size) {
  set_has_metrics_granularity();
  if (metrics_granularity_ == _default_metrics_granularity_) {
    metrics_granularity_ = new ::std::string;
  }
  metrics_granularity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.metrics_granularity)
}
inline ::std::string* Configuration::mutable_metrics_granularity() {
  set_has_metrics_granularity();
  if (metrics_granularity_ == _default_metrics_granularity_) {
    metrics_granularity_ = new ::std::string(*_default_metrics_granularity_);
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.metrics_granularity)
  return metrics_granularity_;
}
inline ::std::string* Configuration::release_metrics_granularity() {
  clear_has_metrics_granularity();
  if (metrics_granularity_ == _default_metrics_granularity_) {
    return NULL;
  } else {
    ::std::string* temp = metrics_granularity_;
    metrics_granularity_ = const_cast< ::std::string*>(_default_metrics_granularity_);
    return temp;
  }
}
inline void Configuration::set_allocated_metrics_granularity(::std::string* metrics_granularity) {
  if (metrics_granularity_ != _default_metrics_granularity_) {
    delete metrics_granularity_;
  }
  if (metrics_granularity) {
    set_has_metrics_granularity();
    metrics_granularity_ = metrics_granularity;
  } else {
    clear_has_metrics_granularity();
    metrics_granularity_ = const_cast< ::std::string*>(_default_metrics_granularity_);
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.metrics_granularity)
}

// optional string metrics_level = 16 [default = "detailed"];
inline bool Configuration::has_metrics_level() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Configuration::set_has_metrics_level() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Configuration::clear_has_metrics_level() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Configuration::clear_metrics_level() {
  if (metrics_level_ != _default_metrics_level_) {
    metrics_level_->assign(*_default_metrics_level_);
  }
  clear_has_metrics_level();
}
inline const ::std::string& Configuration::metrics_level() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.metrics_level)
  return *metrics_level_;
}
inline void Configuration::set_metrics_level(const ::std::string& value) {
  set_has_metrics_level();
  if (metrics_level_ == _default_metrics_level_) {
    metrics_level_ = new ::std::string;
  }
  metrics_level_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.metrics_level)
}
inline void Configuration::set_metrics_level(const char* value) {
  set_has_metrics_level();
  if (metrics_level_ == _default_metrics_level_) {
    metrics_level_ = new ::std::string;
  }
  metrics_level_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.metrics_level)
}
inline void Configuration::set_metrics_level(const char* value, size_t size) {
  set_has_metrics_level();
  if (metrics_level_ == _default_metrics_level_) {
    metrics_level_ = new ::std::string;
  }
  metrics_level_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.metrics_level)
}
inline ::std::string* Configuration::mutable_metrics_level() {
  set_has_metrics_level();
  if (metrics_level_ == _default_metrics_level_) {
    metrics_level_ = new ::std::string(*_default_metrics_level_);
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.metrics_level)
  return metrics_level_;
}
inline ::std::string* Configuration::release_metrics_level() {
  clear_has_metrics_level();
  if (metrics_level_ == _default_metrics_level_) {
    return NULL;
  } else {
    ::std::string* temp = metrics_level_;
    metrics_level_ = const_cast< ::std::string*>(_default_metrics_level_);
    return temp;
  }
}
inline void Configuration::set_allocated_metrics_level(::std::string* metrics_level) {
  if (metrics_level_ != _default_metrics_level_) {
    delete metrics_level_;
  }
  if (metrics_level) {
    set_has_metrics_level();
    metrics_level_ = metrics_level;
  } else {
    clear_has_metrics_level();
    metrics_level_ = const_cast< ::std::string*>(_default_metrics_level_);
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.metrics_level)
}

// optional string metrics_namespace = 17 [default = "KinesisProducerLibrary"];
inline bool Configuration::has_metrics_namespace() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Configuration::set_has_metrics_namespace() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Configuration::clear_has_metrics_namespace() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Configuration::clear_metrics_namespace() {
  if (metrics_namespace_ != _default_metrics_namespace_) {
    metrics_namespace_->assign(*_default_metrics_namespace_);
  }
  clear_has_metrics_namespace();
}
inline const ::std::string& Configuration::metrics_namespace() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.metrics_namespace)
  return *metrics_namespace_;
}
inline void Configuration::set_metrics_namespace(const ::std::string& value) {
  set_has_metrics_namespace();
  if (metrics_namespace_ == _default_metrics_namespace_) {
    metrics_namespace_ = new ::std::string;
  }
  metrics_namespace_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.metrics_namespace)
}
inline void Configuration::set_metrics_namespace(const char* value) {
  set_has_metrics_namespace();
  if (metrics_namespace_ == _default_metrics_namespace_) {
    metrics_namespace_ = new ::std::string;
  }
  metrics_namespace_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.metrics_namespace)
}
inline void Configuration::set_metrics_namespace(const char* value, size_t size) {
  set_has_metrics_namespace();
  if (metrics_namespace_ == _default_metrics_namespace_) {
    metrics_namespace_ = new ::std::string;
  }
  metrics_namespace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.metrics_namespace)
}
inline ::std::string* Configuration::mutable_metrics_namespace() {
  set_has_metrics_namespace();
  if (metrics_namespace_ == _default_metrics_namespace_) {
    metrics_namespace_ = new ::std::string(*_default_metrics_namespace_);
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.metrics_namespace)
  return metrics_namespace_;
}
inline ::std::string* Configuration::release_metrics_namespace() {
  clear_has_metrics_namespace();
  if (metrics_namespace_ == _default_metrics_namespace_) {
    return NULL;
  } else {
    ::std::string* temp = metrics_namespace_;
    metrics_namespace_ = const_cast< ::std::string*>(_default_metrics_namespace_);
    return temp;
  }
}
inline void Configuration::set_allocated_metrics_namespace(::std::string* metrics_namespace) {
  if (metrics_namespace_ != _default_metrics_namespace_) {
    delete metrics_namespace_;
  }
  if (metrics_namespace) {
    set_has_metrics_namespace();
    metrics_namespace_ = metrics_namespace;
  } else {
    clear_has_metrics_namespace();
    metrics_namespace_ = const_cast< ::std::string*>(_default_metrics_namespace_);
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.metrics_namespace)
}

// optional uint64 metrics_upload_delay = 18 [default = 60000];
inline bool Configuration::has_metrics_upload_delay() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Configuration::set_has_metrics_upload_delay() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Configuration::clear_has_metrics_upload_delay() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Configuration::clear_metrics_upload_delay() {
  metrics_upload_delay_ = GOOGLE_ULONGLONG(60000);
  clear_has_metrics_upload_delay();
}
inline ::google::protobuf::uint64 Configuration::metrics_upload_delay() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.metrics_upload_delay)
  return metrics_upload_delay_;
}
inline void Configuration::set_metrics_upload_delay(::google::protobuf::uint64 value) {
  set_has_metrics_upload_delay();
  metrics_upload_delay_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.metrics_upload_delay)
}

// optional uint64 min_connections = 19 [default = 1];
inline bool Configuration::has_min_connections() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Configuration::set_has_min_connections() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Configuration::clear_has_min_connections() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Configuration::clear_min_connections() {
  min_connections_ = GOOGLE_ULONGLONG(1);
  clear_has_min_connections();
}
inline ::google::protobuf::uint64 Configuration::min_connections() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.min_connections)
  return min_connections_;
}
inline void Configuration::set_min_connections(::google::protobuf::uint64 value) {
  set_has_min_connections();
  min_connections_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.min_connections)
}

// optional uint64 rate_limit = 20 [default = 150];
inline bool Configuration::has_rate_limit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Configuration::set_has_rate_limit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Configuration::clear_has_rate_limit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Configuration::clear_rate_limit() {
  rate_limit_ = GOOGLE_ULONGLONG(150);
  clear_has_rate_limit();
}
inline ::google::protobuf::uint64 Configuration::rate_limit() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.rate_limit)
  return rate_limit_;
}
inline void Configuration::set_rate_limit(::google::protobuf::uint64 value) {
  set_has_rate_limit();
  rate_limit_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.rate_limit)
}

// optional uint64 record_max_buffered_time = 21 [default = 100];
inline bool Configuration::has_record_max_buffered_time() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Configuration::set_has_record_max_buffered_time() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Configuration::clear_has_record_max_buffered_time() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Configuration::clear_record_max_buffered_time() {
  record_max_buffered_time_ = GOOGLE_ULONGLONG(100);
  clear_has_record_max_buffered_time();
}
inline ::google::protobuf::uint64 Configuration::record_max_buffered_time() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.record_max_buffered_time)
  return record_max_buffered_time_;
}
inline void Configuration::set_record_max_buffered_time(::google::protobuf::uint64 value) {
  set_has_record_max_buffered_time();
  record_max_buffered_time_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.record_max_buffered_time)
}

// optional uint64 record_ttl = 22 [default = 30000];
inline bool Configuration::has_record_ttl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Configuration::set_has_record_ttl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Configuration::clear_has_record_ttl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Configuration::clear_record_ttl() {
  record_ttl_ = GOOGLE_ULONGLONG(30000);
  clear_has_record_ttl();
}
inline ::google::protobuf::uint64 Configuration::record_ttl() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.record_ttl)
  return record_ttl_;
}
inline void Configuration::set_record_ttl(::google::protobuf::uint64 value) {
  set_has_record_ttl();
  record_ttl_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.record_ttl)
}

// optional string region = 23 [default = ""];
inline bool Configuration::has_region() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Configuration::set_has_region() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Configuration::clear_has_region() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Configuration::clear_region() {
  if (region_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& Configuration::region() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.region)
  return *region_;
}
inline void Configuration::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(value);
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.region)
}
inline void Configuration::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(value);
  // @@protoc_insertion_point(field_set_char:aws.kinesis.protobuf.Configuration.region)
}
inline void Configuration::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aws.kinesis.protobuf.Configuration.region)
}
inline ::std::string* Configuration::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:aws.kinesis.protobuf.Configuration.region)
  return region_;
}
inline ::std::string* Configuration::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Configuration::set_allocated_region(::std::string* region) {
  if (region_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete region_;
  }
  if (region) {
    set_has_region();
    region_ = region;
  } else {
    clear_has_region();
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:aws.kinesis.protobuf.Configuration.region)
}

// optional uint64 request_timeout = 24 [default = 6000];
inline bool Configuration::has_request_timeout() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Configuration::set_has_request_timeout() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Configuration::clear_has_request_timeout() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Configuration::clear_request_timeout() {
  request_timeout_ = GOOGLE_ULONGLONG(6000);
  clear_has_request_timeout();
}
inline ::google::protobuf::uint64 Configuration::request_timeout() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.request_timeout)
  return request_timeout_;
}
inline void Configuration::set_request_timeout(::google::protobuf::uint64 value) {
  set_has_request_timeout();
  request_timeout_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.request_timeout)
}

// optional bool verify_certificate = 25 [default = true];
inline bool Configuration::has_verify_certificate() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Configuration::set_has_verify_certificate() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Configuration::clear_has_verify_certificate() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Configuration::clear_verify_certificate() {
  verify_certificate_ = true;
  clear_has_verify_certificate();
}
inline bool Configuration::verify_certificate() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.verify_certificate)
  return verify_certificate_;
}
inline void Configuration::set_verify_certificate(bool value) {
  set_has_verify_certificate();
  verify_certificate_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.verify_certificate)
}

// optional .aws.kinesis.protobuf.Configuration.ThreadConfig thread_config = 26 [default = PER_REQUEST];
inline bool Configuration::has_thread_config() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Configuration::set_has_thread_config() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Configuration::clear_has_thread_config() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Configuration::clear_thread_config() {
  thread_config_ = 0;
  clear_has_thread_config();
}
inline ::aws::kinesis::protobuf::Configuration_ThreadConfig Configuration::thread_config() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.thread_config)
  return static_cast< ::aws::kinesis::protobuf::Configuration_ThreadConfig >(thread_config_);
}
inline void Configuration::set_thread_config(::aws::kinesis::protobuf::Configuration_ThreadConfig value) {
  assert(::aws::kinesis::protobuf::Configuration_ThreadConfig_IsValid(value));
  set_has_thread_config();
  thread_config_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.thread_config)
}

// optional uint32 thread_pool_size = 27 [default = 64];
inline bool Configuration::has_thread_pool_size() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Configuration::set_has_thread_pool_size() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Configuration::clear_has_thread_pool_size() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Configuration::clear_thread_pool_size() {
  thread_pool_size_ = 64u;
  clear_has_thread_pool_size();
}
inline ::google::protobuf::uint32 Configuration::thread_pool_size() const {
  // @@protoc_insertion_point(field_get:aws.kinesis.protobuf.Configuration.thread_pool_size)
  return thread_pool_size_;
}
inline void Configuration::set_thread_pool_size(::google::protobuf::uint32 value) {
  set_has_thread_pool_size();
  thread_pool_size_ = value;
  // @@protoc_insertion_point(field_set:aws.kinesis.protobuf.Configuration.thread_pool_size)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace kinesis
}  // namespace aws

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aws::kinesis::protobuf::Configuration_ThreadConfig> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aws::kinesis::protobuf::Configuration_ThreadConfig>() {
  return ::aws::kinesis::protobuf::Configuration_ThreadConfig_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
